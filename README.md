# ðŸ“˜ Automata Theory â€“ Unit 1

## ðŸ”¹ Regular Languages and Finite Automata

* * *

### âœ… 1. Closure Properties of Regular Languages

Regular languages are **closed** under the following operations:

- **Union**  
    If L1L_1 and L2L_2 are regular, then L1âˆªL2L_1 \\cup L_2 is also regular.
    
- **Intersection**  
    If L1L_1 and L2L_2 are regular, then L1âˆ©L2L_1 \\cap L_2 is also regular.  
    *Proof idea*: Construct product automaton.
    
- **Complement**  
    If LL is regular, then Lâ€¾\\overline{L} is also regular.  
    *Proof idea*: Take a DFA for LL and swap accepting and non-accepting states.
    
- **Concatenation**  
    If L1L_1 and L2L_2 are regular, then L1â‹…L2L_1 \\cdot L_2 is also regular.
    
- **Kleene Star**  
    If LL is regular, then Lâˆ—L^\* is also regular.
    

* * *

### âœ… 2. Myhillâ€“Nerode Theorem (Minimization of DFA)

**Theorem:**  
A language LâŠ†Î£âˆ—L \\subseteq \\Sigma^\* is regular if and only if the number of equivalence classes of the relation â‰¡L\\equiv_L is finite.

Where xâ‰¡Lyâ€…â€ŠâŸºâ€…â€Šâˆ€zâˆˆÎ£âˆ—,xzâˆˆLâ€…â€ŠâŸºâ€…â€ŠyzâˆˆLx \\equiv_L y \\iff \\forall z \\in \\Sigma^\*, xz \\in L \\iff yz \\in L

**Applications:**

- Provides a method to prove non-regularity.
    
- Foundation for **DFA minimization**.
    

* * *

### âœ… 3. Regular Expressions and Finite Automata Equivalence

**Theorem:** Every language defined by a regular expression can be accepted by some finite automaton, and vice versa.

- Regular Expression â†’\\rightarrow NFA: Use **Thompsonâ€™s Construction**.
    
- NFA â†’\\rightarrow DFA: Use **subset construction**.
    
- DFA â†’\\rightarrow Regular Expression: Use **state elimination method**.
    

* * *

### âœ… 4. Applications of Finite Automata

- **Lexical analysis** in compilers
    
- **Pattern matching** tools like `grep`, `awk`
    
- **Text search algorithms**
    
- **String validation**
    

* * *

### âœ… 5. Mealy and Moore Machines

#### ðŸ“Œ Mealy Machine

- Output depends on **current state and input symbol**.
    
- Output function: Î»:QÃ—Î£â†’Î“\\lambda: Q \\times \\Sigma \\rightarrow \\Gamma
    

#### ðŸ“Œ Moore Machine

- Output depends only on **current state**.
    
- Output function: Î»:Qâ†’Î“\\lambda: Q \\rightarrow \\Gamma
    

**Theorem:** For every Mealy machine, there is an equivalent Moore machine and vice versa.

* * *

### ðŸ§  Example Problems

1.  Construct DFA for the language of all strings over {0,1}\\{0,1\\} ending in 01.
    
2.  Construct NFA and convert it into DFA.
    
3.  Convert regular expression to NFA and then to DFA.
    
4.  Minimize given DFA using equivalence partitioning.
    

* * *

&nbsp;

# ðŸ“˜ Automata Theory â€“ Unit 2

## ðŸ”¹ Non-determinism and Kleeneâ€™s Theorem

* * *

### âœ… 1. Nondeterministic Finite Automaton (NFA)

An NFA is a 5-tuple:

M=(Q,Î£,Î´,q0,F)M = (Q, \\Sigma, \\delta, q_0, F)

Where:

- QQ: Finite set of states
    
- Î£\\Sigma: Input alphabet
    
- Î´:QÃ—Î£â†’2Q\\delta: Q \\times \\Sigma \\rightarrow 2^Q: Transition function (can go to multiple states)
    
- q0âˆˆQq_0 \\in Q: Start state
    
- FâŠ†QF \\subseteq Q: Set of accepting states
    

#### ðŸ§  Characteristics:

- Multiple transitions allowed for the same input
    
- Acceptance if **any** path reaches a final state
    

* * *

### âœ… 2. Epsilon-NFA (Îµ\\varepsilon-NFA)

An extension of NFA that allows **epsilon transitions** (Îµ\\varepsilon):

- Î´:QÃ—(Î£âˆª{Îµ})â†’2Q\\delta: Q \\times (\\Sigma \\cup \\{\\varepsilon\\}) \\rightarrow 2^Q
    
- Input can be consumed **without reading a symbol**
    

* * *

### âœ… 3. DFA and NFA Equivalence Theorem

**Theorem:** For every NFA, there exists a DFA that accepts the same language.

#### âœ… Subset Construction Algorithm:

1.  Each state of DFA is a **subset of NFA states**
    
2.  Start state of DFA is Îµ \\varepsilon-closure of NFAâ€™s start
    
3.  Use Î´\\delta to generate transitions for each subset
    

* * *

### âœ… 4. Kleeneâ€™s Theorem â€“ Part I (with Proof)

**Statement:** A language is regular **iff** it is accepted by a finite automaton.

#### â–¶ Direction 1: Regular Expression â†’ FA

- Use **Thompsonâ€™s Construction** to convert regex to Îµ\\varepsilon-NFA

#### â–¶ Direction 2: FA â†’ Regular Expression

- Use **state elimination** method to extract regex from DFA/NFA

* * *

### âœ… 5. Kleeneâ€™s Theorem â€“ Part II (Intro Only)

**Statement:** A language is regular **iff** it can be described by a regular expression.

Used to confirm the **equivalence** between:

- Languages accepted by FA
    
- Languages generated by regular expressions
    

* * *

### âœ… 6. Minimal Finite Automata Theorem

Every regular language has a **unique minimum state DFA** (up to isomorphism).

#### âœ… DFA Minimization Steps:

1.  Remove **unreachable states**
    
2.  Merge **equivalent states** using partition refinement (Myhill-Nerode relation)
    

* * *

### ðŸ§  Example Problems

1.  Convert Îµ\\varepsilon-NFA to NFA
    
2.  Convert NFA to DFA using subset construction
    
3.  Minimize given DFA
    
4.  Use Kleene's Theorem to convert FA to regex
    

* * *

&nbsp;

# ðŸ“˜ Automata Theory â€“ Unit 3

## ðŸ”¹ Context-Free Grammar (CFG)

* * *

### âœ… 1. Context-Free Grammar (CFG) â€“ Definition

A CFG is a 4-tuple:

G=(V,Î£,R,S)G = (V, \\Sigma, R, S)

Where:

- VV: Set of variables (non-terminals)
    
- Î£\\Sigma: Set of terminals
    
- RR: Set of production rules of the form Aâ†’Î±A \\rightarrow \\alpha, where AâˆˆVA \\in V, Î±âˆˆ(VâˆªÎ£)âˆ—\\alpha \\in (V \\cup \\Sigma)^\*
    
- SâˆˆVS \\in V: Start symbol
    

### âœ… 2. Chomsky Hierarchy

1.  **Type 0**: Recursively enumerable languages (Turing Machines)
    
2.  **Type 1**: Context-sensitive languages
    
3.  **Type 2**: Context-free languages (PDA)
    
4.  **Type 3**: Regular languages (FA)
    

* * *

### âœ… 3. Derivation Trees and Ambiguity

- **Derivation Tree / Parse Tree**: Tree representation of derivations from CFG
    
- **Ambiguous Grammar**: A grammar is ambiguous if **a string has more than one parse tree**
    

#### ðŸ§  Tip:

Try leftmost and rightmost derivations to detect ambiguity.

* * *

### âœ… 4. Closure Properties of CFLs

Context-Free Languages (CFLs) are **closed** under:

- Union
    
- Concatenation
    
- Kleene Star
    

CFLs are **not closed** under:

- Intersection
    
- Complement
    

* * *

### âœ… 5. Grammar Construction

#### âœ… Union:

For CFGs G1G_1 and G2G_2, construct new grammar:

Sâ†’S1Â âˆ£Â S2S \\rightarrow S_1 \\ | \\ S_2

Where S1S_1 and S2S_2 are start symbols of G1G_1 and G2G_2.

#### âœ… Concatenation:

Sâ†’S1S2S \\rightarrow S_1 S_2

#### âœ… Kleene Star:

Sâ†’SSÂ âˆ£Â ÎµS \\rightarrow SS \\ | \\ \\varepsilon

* * *

### âœ… 6. Simplified Forms of CFG

- **Removing Useless Symbols**
    
- **Removing Îµ\\varepsilon-productions**
    
- **Removing Unit Productions**: Aâ†’BA \\rightarrow B
    

* * *

### âœ… 7. Chomsky Normal Form (CNF)

All productions are of the form:

- Aâ†’BCA \\rightarrow BC, where B,CâˆˆVB, C \\in V
    
- Aâ†’aA \\rightarrow a, where aâˆˆÎ£a \\in \\Sigma
    
- Sâ†’ÎµS \\rightarrow \\varepsilon (only allowed if ÎµâˆˆL(G)\\varepsilon \\in L(G))
    

Used in parsing algorithms like **CYK**.

* * *

### âœ… 8. Greibach Normal Form (GNF)

All productions are of the form:

Aâ†’aÎ±,Â whereÂ aâˆˆÎ£,Î±âˆˆVâˆ—A \\rightarrow a\\alpha, \\text{ where } a \\in \\Sigma, \\alpha \\in V^\*

Used in **Top-Down Parsing**.

* * *

### âœ… 9. Backus-Naur Form (BNF)

A metalanguage for describing syntax:

- &lt;nonâˆ’terminal&gt;::=&lt;expression&gt;&lt;non-terminal&gt; ::= &lt;expression&gt;
    
- Common in language design and compilers
    

* * *

### ðŸ§  Example Problems

1.  Construct CFG for palindromes over {a,b}\\{a, b\\}
    
2.  Convert given CFG to CNF
    
3.  Check if a grammar is ambiguous
    
4.  Simplify a CFG by removing useless, null, and unit productions
    

* * *

&nbsp;

# ðŸ“˜ Automata Theory â€“ Unit 4

## ðŸ”¹ Pushdown Automata (PDA) and Parsing

* * *

### âœ… 1. Pushdown Automaton (PDA) â€“ Definition

A PDA is a 7-tuple:

M=(Q,Î£,Î“,Î´,q0,Z0,F)M = (Q, \\Sigma, \\Gamma, \\delta, q_0, Z_0, F)

Where:

- QQ: Finite set of states
    
- Î£\\Sigma: Input alphabet
    
- Î“\\Gamma: Stack alphabet
    
- Î´:QÃ—(Î£âˆª{Îµ})Ã—Î“â†’2QÃ—Î“âˆ—\\delta: Q \\times (\\Sigma \\cup \\{\\varepsilon\\}) \\times \\Gamma \\rightarrow 2^{Q \\times \\Gamma^\*}: Transition function
    
- q0âˆˆQq_0 \\in Q: Start state
    
- Z0âˆˆÎ“Z_0 \\in \\Gamma: Initial stack symbol
    
- FâŠ†QF \\subseteq Q: Set of accepting states
    

#### ðŸ“Œ Acceptance Criteria:

- **By Final State**
    
- **By Empty Stack**
    

* * *

### âœ… 2. Deterministic and Non-deterministic PDA

- **DPDA (Deterministic PDA):**
    
    - At most one move per configuration.
        
    - No ambiguity in input + top stack symbol + state.
        
- **NPDA (Non-deterministic PDA):**
    
    - May have multiple valid transitions for same input configuration.

#### ðŸ“Œ Note:

- All DPDA languages are CFLs.
    
- But **not all CFLs are accepted by DPDAs** (strict subset).
    

* * *

### âœ… 3. CFG and PDA Equivalence Theorem

**Theorem:** For every CFG, there exists a PDA that accepts the same language, and vice versa.

#### â–¶ CFG â†’ PDA:

- Push variables and simulate derivations.

#### â–¶ PDA â†’ CFG:

- Use transitions to generate corresponding productions.

* * *

### âœ… 4. Applications of PDA

- **Parsing in compilers**
    
- **Syntax checking**
    
- **Modeling recursive function calls**
    

* * *

### âœ… 5. Top-Down Parsing (Predictive Parsing)

- Based on **Leftmost derivation**
    
- **LL(k)** parsers (Lookahead)
    
- Uses **First and Follow** sets
    
- Requires **non-ambiguous**, **left-factored**, **non-left-recursive** grammars
    

* * *

### âœ… 6. Bottom-Up Parsing (Shift-Reduce Parsing)

- Based on **Rightmost derivation in reverse**
    
- Builds parse tree from leaves to root
    
- **LR parsers** (LALR, SLR, Canonical LR)
    

* * *

### ðŸ§  Example Problems

1.  Construct PDA for {anbnâˆ£nâ‰¥0}\\{ a^n b^n \\mid n \\geq 0 \\}
    
2.  Design PDA that accepts palindromes over {a,b}\\{a,b\\}
    
3.  Convert CFG to PDA
    
4.  Parse a given string using LL(1) or LR(0) method
    

* * *

&nbsp;

# ðŸ“˜ Automata Theory â€“ Unit 5

## ðŸ”¹ Context-Free Languages (CFLs)

* * *

### âœ… 1. Definition

A language is **Context-Free** if it can be generated by a **Context-Free Grammar (CFG)**:

G=(V,Î£,R,S)G = (V, \\Sigma, R, S)

Where all productions are of the form Aâ†’Î±A \\rightarrow \\alpha, with AâˆˆVA \\in V and Î±âˆˆ(VâˆªÎ£)âˆ—\\alpha \\in (V \\cup \\Sigma)^\*

* * *

### âœ… 2. CFL vs Regular Language

- Every regular language is a CFL.
    
- Not every CFL is regular (e.g., {anbnâˆ£nâ‰¥0}\\{a^n b^n \\mid n \\geq 0\\})
    

* * *

### âœ… 3. Closure Properties of CFLs

CFLs are **closed** under:

- Union
    
- Concatenation
    
- Kleene Star
    

CFLs are **not closed** under:

- Intersection
    
- Complement
    

#### ðŸ§  Tip:

Intersection with regular languages **is** closed.

CFLâˆ©REGULAR=CFLCFL \\cap REGULAR = CFL

* * *

### âœ… 4. Pumping Lemma for CFLs

Used to **prove a language is not a CFL**.

#### Statement:

If LL is a CFL, then âˆƒÂ pâˆˆN\\exists \\ p \\in \\mathbb{N}, such that for any zâˆˆLz \\in L with âˆ£zâˆ£â‰¥p|z| \\geq p,  
zz can be written as:

z=uvwxyz = uvwxy

Such that:

1.  âˆ£vwxâˆ£â‰¤p|vwx| \\leq p
    
2.  vxâ‰ Îµvx \\neq \\varepsilon
    
3.  âˆ€iâ‰¥0,Â uviwxiyâˆˆL\\forall i \\geq 0,\\ uv^i w x^i y \\in L
    

Use this lemma to show contradiction for non-CFLs.

* * *

### âœ… 5. CFL Properties with Examples

| Operation | Closure | Example |
| --- | --- | --- |
| Union | Yes | {anbn}âˆª{anb2n}\\{a^n b^n\\} \\cup \\{a^n b^{2n}\\} |
| Concatenation | Yes | {anbn}â‹…{bncn}\\{a^n b^n\\} \\cdot \\{b^n c^n\\} |
| Kleene Star | Yes | (anbn)âˆ—(a^n b^n)^\* |
| Intersection | No  | {anbncn}=L1âˆ©L2\\{a^n b^n c^n\\} = L_1 \\cap L_2 |
| Complement | No  | By DeMorgan's Law: AâˆªBâ€¾=Aâ€¾âˆ©Bâ€¾\\overline{A \\cup B} = \\overline{A} \\cap \\overline{B} |

* * *

### ðŸ§  Example Problems

1.  Prove {anbncnâˆ£nâ‰¥0}\\{a^n b^n c^n \\mid n \\geq 0\\} is **not** a CFL using pumping lemma
    
2.  Show {wwRâˆ£wâˆˆ{a,b}âˆ—}\\{ww^R \\mid w \\in \\{a,b\\}^\*\\} is CFL (palindrome)
    
3.  Test closure under union for two given CFLs
    

* * *

&nbsp;

# ðŸ“˜ Automata Theory â€“ Unit 6

## ðŸ”¹ Turing Machine (TM)

* * *

### âœ… 1. Turing Machine â€“ Definition

A Turing Machine is a 7-tuple:

M=(Q,Î£,Î“,Î´,q0,B,F)M = (Q, \\Sigma, \\Gamma, \\delta, q_0, B, F)

Where:

- QQ: Finite set of states
    
- Î£\\Sigma: Input alphabet (does not include blank symbol BB)
    
- Î“\\Gamma: Tape alphabet (includes BB)
    
- Î´:QÃ—Î“â†’QÃ—Î“Ã—{L,R}\\delta: Q \\times \\Gamma \\rightarrow Q \\times \\Gamma \\times \\{L, R\\}: Transition function
    
- q0âˆˆQq_0 \\in Q: Start state
    
- BâˆˆÎ“B \\in \\Gamma: Blank symbol
    
- FâŠ†QF \\subseteq Q: Set of accepting (final) states
    

* * *

### âœ… 2. TM as Language Acceptor

- TM accepts a language by **entering a final state**.
    
- Alternatively, by **halting** in a valid configuration.
    

* * *

### âœ… 3. Computing a Partial Function with TM

TMs can **compute functions** by writing output on tape:

f:Î£âˆ—â†’Î£âˆ—Â (partial)f: \\Sigma^\* \\rightarrow \\Sigma^\* \\text{ (partial)}

If TM halts on input ww, then output is the tape content.

* * *

### âœ… 4. Combining Turing Machines

Used to construct complex machines from simpler ones:

- Sequence of TMs: Output of one becomes input of next.
    
- Conditional branching (based on symbol/state).
    
- Subroutines (modular design).
    

* * *

### âœ… 5. Variants of Turing Machines

All these variants are **equivalent in power** (can simulate each other):

| Variant | Description |
| --- | --- |
| Multi-tape TM | Multiple tapes with individual heads |
| Multi-track TM | One tape, multiple tracks |
| Non-deterministic TM (NTM) | May have multiple transitions |
| Off-line TMs | Read-only input tape, working tape |
| Semi-infinite TM | Infinite in only one direction |
| TM with stay option | Head can stay in place (move: L/R/S) |

* * *

### âœ… 6. Universal Turing Machine (UTM)

- A UTM takes as input âŸ¨M,wâŸ©\\langle M, w \\rangle, where MM is encoded TM and ww is input string.
    
- Simulates TM MM on input ww.
    

**Key Idea:** TMs can encode other TMs â†’ foundation for **programmable computers**.

* * *

### âœ… 7. Applications of Turing Machines

- Defining computability and decidability
    
- Models for general-purpose computing
    
- Basis for modern computer architecture
    

* * *

### ðŸ§  Example Problems

1.  Design TM to accept {anbnâˆ£nâ‰¥1}\\{a^n b^n \\mid n \\geq 1\\}
    
2.  Create TM that computes binary addition
    
3.  Construct UTM that simulates another TM
    

* * *

&nbsp;

&nbsp;
